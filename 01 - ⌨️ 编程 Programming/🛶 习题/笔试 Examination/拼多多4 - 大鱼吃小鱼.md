给定一个整型数组，里面每一个元素代表一只鱼的血量。每一回合，有一只鱼可以吃掉血量比它少的相邻的鱼，然后血量加上被吃掉的鱼。

问，在所有可能的互相吃的组合里，每一只鱼最少在几回合内会被吃掉。

输入格式：

```
2 5 7 8 1 3 2 9 1
```


---

```cpp
#include <climits>
#include <iostream>
#include <vector>
using namespace std;

int leftbinarysearch(vector<int>& arr, int i_low, int i_high, int val){
    int p = (i_low + i_high)/2;

    if (val >= arr[p]) return leftbinarysearch(arr, p+1, i_high, val);
    else if (val < arr[p]){
        if (val < arr[p-1]) return leftbinarysearch(arr, i_low, p-1, val);
        else return p;
    }
    return p;
}

int rightbinarysearch(vector<int>& arr, int i_low, int i_high, int val){
    int p = (i_low + i_high)/2;

    if (val >= arr[p]) return rightbinarysearch(arr, i_low, p-1, val);
    else if (val < arr[p]){
        if (val < arr[p+1]) return rightbinarysearch(arr, p+1, i_high, val);
        else return p;
    }
    return p;
}


int main() {
    int n_fish;
    int sum = 0;
    int temp;
    int cut;
    int inflat;
    int i_low, i_high;
    int left_dist, right_dist;
    vector<int> fish;
    vector<int> left_accu;
    vector<int> right_accu;
    cin >> n_fish;

    for (int i = 0; i < n_fish; i++){
        cin >> temp;
        fish.push_back(temp);
        sum += temp;
        left_accu.push_back(sum);
    }

    sum = 0;
    for (int i = n_fish - 1; i >= 0; i++){
        sum += fish[i];
        right_accu.push_back(sum);
    }

    // Calculate
    for (int i = 0; i < n_fish; i++){
        // From left
        if (i != n_fish - 1){
            inflat = fish[i] + left_accu[i];
            i_low = i + 1;
            i_high = n_fish - 1;

            if (inflat >= left_accu[i_high]) left_dist = -1;
            else if (inflat < left_accu[i_low]) left_dist = 1;
            else left_dist = leftbinarysearch(left_accu, i_low, i_high, inflat) - i; 
        }

        // From right
        if (i != 0){
            inflat = fish[i] + right_accu[i];
            i_high = i - 1;
            i_low = 0;

            if (inflat >= right_accu[0]) right_dist = -1;
            else if (inflat < right_accu[i_high]) right_dist = 1;
            else right_dist = i - rightbinarysearch(right_accu, i_low, i_high, inflat); 
        }

        if (left_dist == -1){
            cout << right_dist;
            return 0;
        }
        else if (right_dist == -1){
            cout << left_dist;
            return 0;
        }
        else return left_dist > right_dist ? left_dist : right_dist;
    }
}
// 64 位输出请用 printf("%lld")
```