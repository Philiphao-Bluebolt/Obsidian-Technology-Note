映射是一种储存键值对的数据结构，也称为**字典**（Dictionary）或**关联数组**（Associative Array），可以通过输入**键**（Key）快速查找对应的元素**值**（Value）。如果映射储存的键与值总是相同，则被称为**集合**（Set）

+ **[变体](#变体%20Varieties)** - [无序](#无序映射%20Unordered%20Map) · [有序](#有序映射%20Ordered%20Map) · [多重](#多重映射%20Multimap)
+ **[实现](#实现方法%20Implementation%20Methods)** - [哈希表](#哈希表%20Hash%20table) · [平衡二叉树](#平衡二叉树%20Balanced%20Binary%20Tree)


---
## 变体 Varieties

### 无序映射 Unordered Map

无序映射的特点是内部储存键值对的**键不能重复**，而且元素之间**没有顺序关系**，类似数学上的集合。无序映射常使用[哈希表](#哈希表%20Hash%20table)实现，其搜索操作的时间复杂度可以压缩至常数级$O(1)$，适合用于记录已经使用过的数据。




### 有序映射 Ordered Map

有序映射的特点是



### 多重映射 Multimap



---
## 实现方法 Implementation Methods


### 哈希表 Hash table

+ **参考** - [Wikipedia](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)

哈希表也称为散列表，其工作原理与电话簿类似，通过一个 🏹 [**哈希函数**](哈希函数%20Hash%20Function.md)（Hash Function）将输入的键直接映射到一个内存地址，从而大幅度降低搜索时长，实现常数级搜索复杂度$O(1)$。表内元素没有先后顺序，仅用于实现无序映射。

若两个不同的键被哈希函数映射到同一个内存值，就会发生 💥 **哈希冲突**（Hash Collision）。哈希表冲突有三种解决方法。

1. ⛓️‍💥 **链表法 Chaining** - 也称为拉链法，用称为 🪣 **桶**（Bucket）的链表或红黑树容器存放所有哈希映射值相同的键值对，是**最常用**的冲突解决方法，缺点是需要额外的储存空间。

2. 📬️ **开放地址法 Open Addressing** - 当冲突发生时，以某种规则访问哈希表内的其他内存地址，比如访问下一个地址或随机访问其他地址。

3. 🔀 **重哈希法 Rehashing** - 每当发生冲突时重新设置哈希函数，更新所有元素的位置，直到不发生冲突。由于重哈希耗时长，这种方法很少使用。

如果哈希表内桶的个数与元素相比过少，键值对映射冲突会变得非常频繁，桶内存放大量元素，总体搜索时间复杂度随元素增加而上升，逼近最坏情况$O(n)$，此时必须 🔀 **重哈希**，增加桶的个数。

+ 🗃️ **装载因子 Load Factor** - 元素（键值对）个数除以桶的个数，即平均每个桶内存放的元素个数，一般不宜超过0.75。超过阈值时则会触发重哈希。







以电话簿为例，需要储存的键值对是“名字 - 电话”，







### 平衡二叉树 Balanced Binary Tree
