+ **链接**：[Rotate Array](https://leetcode.com/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150)

将一个长度为`n`的数组所有元素向右循环移动`k`格（最右的会回到最左），求所得数组。注意`k`
可以是一个任意大的正整数。

这个问题有很多解法，最优的解法具有线性时间复杂度和常数空间复杂度

+ [朴素解法一：临时容器](#朴素解法一：临时容器)
+ [朴素解法二：多次移动](#朴素解法二：多次移动)
+ [最优解法](#最优解法)

---
## 朴素解法一：临时容器

+ **时间复杂度**：$O(n)$
+ **空间复杂度**：$O(n)$

最简单的方法是新建一个与原数组等大的临时数组，每个元素右移`k`位后依次放入对应的新位置，然后再把临时数组的元素按照序号一一对应移回到原数组。

两次移动共执行了`2n`步，临时数组占用的内存空间为`n`，是一个可以接受的解法，但不是最优解。

---
## 朴素解法二：多次移动

+ **时间复杂度**：$O(nk)$
+ **空间复杂度**：$O(1)$

数组所有元素每次只向右移动一格，重复`k`次。这个方法倒是不需要太多额外空间，但是时间复杂度`nk`变成了二次级别

---
## 回环法

+ **时间复杂度**：$O(nk)$
+ **空间复杂度**：$O(1)$

数组元素向右移位的过程可以看作是若干个位置组成的循环，把这些循环全部转一遍就能得到最终结果。不过目前还没调试成功。


---
## 最优解法

+ **时间复杂度**：$O(n)$
+ **空间复杂度**：$O(1)$****